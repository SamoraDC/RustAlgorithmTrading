"""
Base strategy class and signal definitions
"""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import pandas as pd
from loguru import logger


class SignalType(Enum):
    """Trading signal types"""
    LONG = "LONG"
    SHORT = "SHORT"
    EXIT = "EXIT"
    HOLD = "HOLD"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy

    Attributes:
        timestamp: Time when signal was generated
        symbol: Stock symbol
        signal_type: Type of signal (BUY, SELL, HOLD)
        price: Price at signal generation
        quantity: Suggested quantity to trade
        confidence: Signal confidence (0-1)
        metadata: Additional signal information
    """
    timestamp: datetime
    symbol: str
    signal_type: SignalType
    price: float
    quantity: float = 0.0
    confidence: float = 1.0
    metadata: Dict[str, Any] = None

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


class Strategy(ABC):
    """
    Abstract base class for trading strategies

    All trading strategies should inherit from this class and implement
    the required abstract methods.
    """

    def __init__(self, name: str, parameters: Optional[Dict[str, Any]] = None):
        """
        Initialize strategy

        Args:
            name: Strategy name
            parameters: Strategy parameters dictionary
        """
        self.name = name
        self.parameters = parameters or {}
        self.signals = []
        self.positions = {}
        logger.info(f"Strategy '{name}' initialized with parameters: {self.parameters}")

    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> list[Signal]:
        """
        Generate trading signals based on market data

        Args:
            data: DataFrame with market data (must include OHLCV)

        Returns:
            List of Signal objects
        """
        pass

    @abstractmethod
    def calculate_position_size(
        self,
        signal: Signal,
        account_value: float,
        current_position: float = 0.0
    ) -> float:
        """
        Calculate position size for a signal

        Args:
            signal: Trading signal
            account_value: Current account value
            current_position: Current position size

        Returns:
            Suggested position size
        """
        pass

    def should_enter(self, signal: Signal) -> bool:
        """
        Determine if should enter a position

        Args:
            signal: Trading signal

        Returns:
            True if should enter position
        """
        return signal.signal_type in [SignalType.LONG, SignalType.SHORT]

    def should_exit(self, signal: Signal, current_position: float) -> bool:
        """
        Determine if should exit a position

        Args:
            signal: Trading signal
            current_position: Current position size

        Returns:
            True if should exit position
        """
        # Exit signal explicitly
        if signal.signal_type == SignalType.EXIT:
            return True
        # Exit if holding long and signal is short, or holding short and signal is long
        if current_position > 0 and signal.signal_type == SignalType.SHORT:
            return True
        if current_position < 0 and signal.signal_type == SignalType.LONG:
            return True
        return False

    def validate_data(self, data: pd.DataFrame) -> bool:
        """
        Validate that data has required columns

        Args:
            data: DataFrame to validate

        Returns:
            True if data is valid
        """
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        missing_columns = [col for col in required_columns if col not in data.columns]

        if missing_columns:
            logger.error(f"Missing required columns: {missing_columns}")
            return False

        return True

    def get_parameter(self, key: str, default: Any = None) -> Any:
        """
        Get strategy parameter with default fallback

        Args:
            key: Parameter key
            default: Default value if key not found

        Returns:
            Parameter value
        """
        return self.parameters.get(key, default)

    def set_parameter(self, key: str, value: Any) -> None:
        """
        Set strategy parameter

        Args:
            key: Parameter key
            value: Parameter value
        """
        self.parameters[key] = value
        logger.info(f"Strategy parameter updated: {key} = {value}")

    def reset(self) -> None:
        """Reset strategy state"""
        self.signals = []
        self.positions = {}
        logger.info(f"Strategy '{self.name}' reset")

    def __repr__(self) -> str:
        return f"Strategy(name='{self.name}', parameters={self.parameters})"
